# 레시피 추천 시스템 비교: FAISS vs RAG

## 📊 현재 상황

### ✅ **기본 추천 시스템: FAISS 기반** (현재 사용 중)

**엔드포인트**: `POST /api/recommend`

**사용 위치**: 
- 프론트엔드: `take_picture_screen.dart` → `/api/recommend` 호출
- Spring Boot: `RecipeController.java` → FastAPI `/api/fastapi/recommend` 전달
- FastAPI: `api.py` → `recommend_recipes_new_table()` 호출

**기술 스택**:
- **FAISS**: 벡터 검색 엔진
- **SentenceTransformer**: 텍스트 임베딩 (KR-SBERT-V40K-klueNLI-augSTS)
- **가중치 점수 계산**: 주재료 2배, 부재료 1배

**데이터 소스**:
- `recipe_new` 테이블 (537개 레시피)
- `faiss_store/index_new.faiss` (벡터 인덱스)
- `faiss_store/metadata_new.pkl` (메타데이터)

**동작 방식**:
```python
1. 사용자 재료 → 임베딩 벡터 변환
2. FAISS로 유사한 레시피 검색 (top_k=500)
3. 주재료/부재료 매칭 점수 계산
4. 가중치 적용: (주재료 매칭 × 2.0) + (부재료 매칭 × 1.0) - distance
5. 점수 순으로 정렬하여 반환
```

**장점**:
- ✅ 빠른 검색 속도 (FAISS 벡터 검색)
- ✅ 의미 기반 검색 (임베딩 벡터)
- ✅ 주재료/부재료 가중치 적용으로 정확도 향상
- ✅ 대규모 데이터 처리 가능

---

### ⚠️ **RAG 기반 추천 시스템** (레거시, 현재 미사용)

**엔드포인트**: `POST /api/recommend/rag`

**사용 위치**: 
- 프론트엔드에서 **사용하지 않음**
- Spring Boot: `RecipeController.java` → `/recommend/rag` 엔드포인트 존재
- FastAPI: `api.py` → `rag_chain.py`의 RAGChain 사용

**기술 스택**:
- **단순 문자열 매칭**: 재료명이 레시피에 포함되는지 확인
- **metadata.pkl**: 레시피 메타데이터 파일

**데이터 소스**:
- `faiss_store/metadata.pkl` (레거시 메타데이터)
- `recipe` 테이블 (24만개 레시피, 구버전)

**동작 방식**:
```python
1. metadata.pkl에서 모든 레시피 로드
2. 사용자 재료를 레시피 재료 문자열과 비교
3. 매칭된 재료 개수로 점수 계산
4. 점수 순으로 정렬하여 반환 (top_k=50)
```

**단점**:
- ❌ 느린 검색 속도 (전체 레시피 순회)
- ❌ 단순 문자열 매칭 (의미 이해 없음)
- ❌ 주재료/부재료 구분 없음
- ❌ 가중치 적용 없음
- ❌ 대규모 데이터 처리 비효율적

---

## 🔍 왜 두 개가 있는가?

### 역사적 배경

1. **초기 구현**: RAG 기반 추천 시스템
   - LangChain 기반으로 구현
   - 단순 문자열 매칭 방식
   - 레거시 `recipe` 테이블 사용 (24만개)

2. **성능 개선**: FAISS 기반 추천 시스템
   - 벡터 검색으로 성능 향상
   - 주재료/부재료 가중치 적용
   - `recipe_new` 테이블 사용 (537개, 주재료/부재료 정보 포함)

3. **현재 상태**: 
   - **기본 추천**: FAISS 기반 (활발히 사용 중)
   - **RAG 추천**: 레거시 (호환성 유지, 실제 사용 안 함)

---

## 📋 비교표

| 항목 | FAISS 기반 (현재) | RAG 기반 (레거시) |
|------|------------------|------------------|
| **엔드포인트** | `/api/recommend` | `/api/recommend/rag` |
| **사용 여부** | ✅ 활발히 사용 | ❌ 미사용 |
| **검색 방식** | 벡터 유사도 검색 | 문자열 매칭 |
| **속도** | 빠름 (FAISS) | 느림 (순회 검색) |
| **정확도** | 높음 (의미 기반) | 낮음 (단순 매칭) |
| **가중치** | 주재료 2배 적용 | 없음 |
| **데이터 소스** | recipe_new (537개) | recipe (24만개) |
| **주재료/부재료** | 구분하여 처리 | 구분 없음 |
| **임베딩 모델** | SentenceTransformer | 없음 |

---

## 💡 결론

**현재 보유 재료 기반 레시피 추천은 FAISS 기반입니다.**

- ✅ 프론트엔드에서 `/api/recommend` 호출 → FAISS 기반
- ✅ 주재료/부재료 가중치 적용
- ✅ 빠르고 정확한 벡터 검색

**RAG 기반 추천은 레거시입니다.**

- ❌ 프론트엔드에서 사용하지 않음
- ❌ 단순 문자열 매칭 방식
- ⚠️ 호환성을 위해 유지 중이지만 실제로는 사용되지 않음

---

## 🔧 개선 제안

### 옵션 1: RAG 엔드포인트 제거
- 사용하지 않는 코드 정리
- 유지보수 부담 감소

### 옵션 2: RAG를 진짜 RAG로 개선
- FAISS 벡터 검색 + LLM 생성 결합
- 검색된 레시피를 LLM이 요약/추천 문구 생성
- 현재는 "RAG"라는 이름만 있고 실제로는 단순 검색

### 옵션 3: 현재 상태 유지
- 호환성 유지
- 필요시 레거시 시스템으로 폴백 가능

---

**권장 사항**: 옵션 1 (RAG 엔드포인트 제거)
- 현재 사용하지 않음
- 코드 복잡도 감소
- 유지보수 용이

